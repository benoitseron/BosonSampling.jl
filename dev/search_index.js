var documenterSearchIndex = {"docs":
[{"location":"tutorial/user_defined_models.html#Defining-new-models","page":"Implementing new models","title":"Defining new models","text":"","category":"section"},{"location":"tutorial/user_defined_models.html","page":"Implementing new models","title":"Implementing new models","text":"One of the strengths of this package is the ease with which users may implement new models, for instance, new types of detectors (noisy, gaussian, threshold,...) without modifying the overall package structure: all calls will be similarly written, allowing for a very easy change of model with no extra coding (apart from the model itself).","category":"page"},{"location":"tutorial/user_defined_models.html","page":"Implementing new models","title":"Implementing new models","text":"For instance, one could implement a new type of OutputMeasurement that would be similar to the FockDetection but would account for random dark-counts in the detectors, or detector (in)efficiency.","category":"page"},{"location":"tutorial/user_defined_models.html","page":"Implementing new models","title":"Implementing new models","text":"Moreover, this is done without loss of performance given Julia's fast execution times. This would be much harder to do efficiently in a package linking a fast but lengthy to code programming language (C, Fortran,...) with a user interface language linking the fast routines that is easy to write but slow to execute (Python,...).","category":"page"},{"location":"tutorial/user_defined_models.html","page":"Implementing new models","title":"Implementing new models","text":"Note however that you can also use the above trick with our package if you wish to use our fast functions with a Python interface.","category":"page"},{"location":"tutorial/user_defined_models.html","page":"Implementing new models","title":"Implementing new models","text":"It is thus, in the authors' opinion, a good choice to use Julia for experimentalists who may want to account for a lot of subtleties not included in this package (or simply proper to their own experiment) as well as for theorists who may be interested in implementing new theoretical models, say nonlinear boson sampling.","category":"page"},{"location":"types/partitions.html","page":"Partitions","title":"Partitions","text":"Modules = [BosonSampling]\nPages = [\"types/partitions.jl\"]\nPrivate = false","category":"page"},{"location":"types/partitions.html#BosonSampling.ModeOccupation","page":"Partitions","title":"BosonSampling.ModeOccupation","text":"ModeOccupation(state)\n\nfields:\n     - n::Int\n     - m::Int\n     - state::Vector{Int}\n\n\n\n\n\n","category":"type"},{"location":"types/partitions.html#BosonSampling.Partition","page":"Partitions","title":"BosonSampling.Partition","text":"Partition(subsets::Vector{Subset})\n\nCreate a partition from multiple Subset.\n\n\n\n\n\n","category":"type"},{"location":"types/partitions.html#BosonSampling.PartitionOccupancy","page":"Partitions","title":"BosonSampling.PartitionOccupancy","text":"PartitionOccupancy(counts::ModeOccupation, n::Int, partition::Partition)\n\nFields:         - counts::ModeOccupation         - partition::Partition         - n::Int         - m::Int\n\n\n\n\n\n","category":"type"},{"location":"types/partitions.html#BosonSampling.Subset","page":"Partitions","title":"BosonSampling.Subset","text":"Subset(state::Vector{Int})\n\nCreate a mode occupation list with at most one count per mode.\n\nFields:\n     - n::Int\n     - m::Int\n     - subset::Vector{Int}\n\n\n\n\n\n","category":"type"},{"location":"types/partitions.html#BosonSampling.equilibrated_partition-Tuple{Any, Any}","page":"Partitions","title":"BosonSampling.equilibrated_partition","text":"equilibrated_partition(m,n_subsets)\n\nReturns a most equilibratedpartition according to the principles of [`equilibratedpartition_vector`](@ref).\n\n\n\n\n\n","category":"method"},{"location":"types/partitions.html#BosonSampling.equilibrated_partition_vector-Tuple{Any, Any}","page":"Partitions","title":"BosonSampling.equilibrated_partition_vector","text":"equilibrated_partition_vector(m,n_subsets)\n\nReturns a (most) equilibrated partition possible by euclidian division.\n\n(a problem is that euclidian distribution may give nsubsets or nsubsets+1 if not done like below - here it is the most obvious thing I could think of to get a somewhat equilibrated partition with a constant number of subsets)\n\n\n\n\n\n","category":"method"},{"location":"types/partitions.html#BosonSampling.first_modes-Tuple{Int64, Int64}","page":"Partitions","title":"BosonSampling.first_modes","text":"first_modes(n::Int, m::Int)\n\nCreate a ModeOccupation with n photons in the first sites of m modes.\n\n\n\n\n\n","category":"method"},{"location":"types/partitions.html#BosonSampling.occupies_all_modes-Tuple{Partition}","page":"Partitions","title":"BosonSampling.occupies_all_modes","text":"occupies_all_modes(part::Partition)\n\nCheck wether a partition occupies all modes or not.\n\n\n\n\n\n","category":"method"},{"location":"types/partitions.html#BosonSampling.partition_from_subset_lengths-Tuple{Any}","page":"Partitions","title":"BosonSampling.partition_from_subset_lengths","text":"partition_from_subset_lengths(subset_lengths)\n\nReturn a partition from a vector of subset lengths.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/optimization.html#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"tutorial/optimization.html","page":"Optimization","title":"Optimization","text":"An interesting question in BosonSampling is to find interferometers that of maximize certain properties.","category":"page"},{"location":"tutorial/optimization.html","page":"Optimization","title":"Optimization","text":"We provide the function minimize_over_unitary_matrices() which operates a conjugate gradient algorithm for the optimization over unitary matrices. It is implemented from Conjugate gradient algorithm for optimization under unitary matrix constraint from Traian Abrudan, Jan Eriksson, Visa Koivunen.","category":"page"},{"location":"functions/bayesian.html","page":"Certification","title":"Certification","text":"Modules = [BosonSampling]\nPages = [\"bayesian.jl\"]\nPrivate = false","category":"page"},{"location":"types/input.html","page":"Inputs","title":"Inputs","text":"Modules = [BosonSampling]\nPages = [\"input.jl\"]\nPrivate = false","category":"page"},{"location":"types/input.html#BosonSampling.Bosonic","page":"Inputs","title":"BosonSampling.Bosonic","text":"Type used to notify that the input is made of FockState indistiguishable photons.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.CoherentState","page":"Inputs","title":"BosonSampling.CoherentState","text":"Type used to notify that the input is made of coherent state.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.Distinguishable","page":"Inputs","title":"BosonSampling.Distinguishable","text":"Model of distinguishable photons FockState.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.Gaussian","page":"Inputs","title":"BosonSampling.Gaussian","text":"Type used to notify that the input is made of Gaussian states.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.GramMatrix","page":"Inputs","title":"BosonSampling.GramMatrix","text":"GramMatrix{T}(n::Int) where {T<:InputType}\nGramMatrix{T}(n::Int, distinguishability_param::Real) where {T<:InputType}\nGramMatrix{T}(n::Int, S::Matrix) where {T<:InputType}\n\nMatrix of partial distinguishability. Will automatically generate the proper matrix related to the provided InputType.\n\nFields:\n    - n::Int: photons number\n    - S::Matrix: Gram matrix\n    - rank::Union{Int, Nothing}\n    - distinguishability_param::Union{Real, Nothing}\n    - generating_vectors::OrthonormalBasis\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.Input","page":"Inputs","title":"BosonSampling.Input","text":"Input{T<:InputType}\nInput{T}(r::ModeOccupation) where {T<:InputType}\nInput{T}(r::ModeOccupation, G::GramMatrix) where {T<:InputType}\n\nInput state at the entrance of the interferometer.\n\nFields:\n    - r::ModeOccupation\n    - n::Int\n    - m::Int: modes numbers\n    - G::GramMatrix\n    - distinguishability_param::Union{Real, Nothing}\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.InputType","page":"Inputs","title":"BosonSampling.InputType","text":"Supertype to any concrete input type such as Bosonic, PartDist, Distinguishable and Undef.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.OneParameterInterpolation","page":"Inputs","title":"BosonSampling.OneParameterInterpolation","text":"One parameter model of partial distinguishability interpolating between indistinguishable and fully distinguishable photons FockState.\n\nnote: Reference\nSampling of partially distinguishable bosons and the relation to the multidimensional permanent\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.OrthonormalBasis","page":"Inputs","title":"BosonSampling.OrthonormalBasis","text":"OrthonormalBasis(vector_matrix::Union{Matrix, Nothing})\n\nBasis of vectors v_1v_n stored as columns in a n-by-r matrix possibly empty.\n\nFields:\n    vectors_matrix::Union{Matrix,Nothing}\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.PartDist","page":"Inputs","title":"BosonSampling.PartDist","text":"Type used to notify that the input is made of FockState partially distinguishable photons.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.RandomGramMatrix","page":"Inputs","title":"BosonSampling.RandomGramMatrix","text":"Model of partially distinguishable photons FockState described by a randomly generated GramMatrix.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.SingleModeSqueezedVacuum","page":"Inputs","title":"BosonSampling.SingleModeSqueezedVacuum","text":"Type used to notify that the input is made of single mode squeezed state.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.ThermalState","page":"Inputs","title":"BosonSampling.ThermalState","text":"Type used to notify that the input is made of thermal state.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.Undef","page":"Inputs","title":"BosonSampling.Undef","text":"Model of photons FockState with undefined GramMatrix.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.UserDefinedGramMatrix","page":"Inputs","title":"BosonSampling.UserDefinedGramMatrix","text":"Model of partially distinguishable photons FockState described by a provided GramMatrix.\n\n\n\n\n\n","category":"type"},{"location":"types/input.html#BosonSampling.VacuumState","page":"Inputs","title":"BosonSampling.VacuumState","text":"Type used to notify that the input is made of the vacuum state.\n\n\n\n\n\n","category":"type"},{"location":"functions/proba_tools.html","page":"Tools","title":"Tools","text":"Modules = [BosonSampling]\nPages = [\"proba_tools.jl\"]\nPrivate = false","category":"page"},{"location":"functions/proba_tools.html#BosonSampling.clean_pdf","page":"Tools","title":"BosonSampling.clean_pdf","text":"clean_pdf(A::Array, atol=ATOL)\n\nChecks wether an array is an acceptable discrete probability distribution with tolerance ATOL. If so, converts its elements to normalized positive real numbers.\n\n\n\n\n\n","category":"function"},{"location":"functions/proba_tools.html#BosonSampling.clean_proba","page":"Tools","title":"BosonSampling.clean_proba","text":"clean_proba_(probability:Number, atol=ATOL)\n\nChecks whether a (complex) number is close enough to a valid probability with tolerance ATOL. If so, convert it to a positive real number.\n\n\n\n\n\n","category":"function"},{"location":"functions/proba_tools.html#BosonSampling.isa_pdf-Tuple{Any}","page":"Tools","title":"BosonSampling.isa_pdf","text":"isa_pdf(pdf)\n\nAsserts if pdf\tis a valid probability distribution.\n\n\n\n\n\n","category":"method"},{"location":"functions/proba_tools.html#BosonSampling.sqr-Tuple{Any, Any}","page":"Tools","title":"BosonSampling.sqr","text":"sqr(a,b)\n\nComputes the euclidian distance between two probability distributions.\n\n\n\n\n\n","category":"method"},{"location":"functions/proba_tools.html#BosonSampling.tvd-Tuple{Any, Any}","page":"Tools","title":"BosonSampling.tvd","text":"tvd(a,b)\n\nComputes the total variation distance between two probability distributions.\n\n\n\n\n\n","category":"method"},{"location":"intro.html#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"Photon creation operators are changed as a_j - sum_j U_jk b_k when going through the interferometer opU. Thus, the rows correspond to the input, columns to the output, that is: the probability that a single goes from j to k is U_jk^2","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"This is the conventions used by most people. Let us warn that Valery Shchesnovich uses a convention that is incompatible: opU needs to be changed to opU^dagger. (And likewise defines the Gram matrix as the transpose of ours, see below.)","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"By default, we will use Tichy's conventions","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"Input vector = r or input_state\nOutput vector = s or output_state\nFor detection that if not just an event output_measurement\ninterferometer matrix = U\ninterferometer matrix M of Tichy (with rows corresponding to the input,...) = scattering_matrix\ndimension of the interferometer = m (size of the interferometer) or (n in previous code","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"or where the number of photons is irrelevant or called number_photons)","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"number of modes occupied = n, number_photons","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"See for Tichy: https://arxiv.org/abs/1410.7687, and for Shchesnovich: https://arxiv.org/abs/1410.1506","category":"page"},{"location":"intro.html#Operators-change","page":"Conventions","title":"Operators change","text":"","category":"section"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"Tichy: \\hat{A}_{j,|\\Phi\\rangle}^{\\dagger} \\rightarrow \\hat{U} \\hat{A}_{j,|\\Phi\\rangle}^{\\dagger} \\hat{U}^{-1}=\\sum_{k=1}^{m} U_{j, k} \\hat{B}_{k,|\\Phi\\rangle}^{\\dagger}\nShchesnovich: A spatial unitary network can be defined by an unitary transformation between input $a_{k, s}^{\\dagger}(\\omega)$ and output $b_{k, s}^{\\dagger}(\\omega)$ photon creation operators, we set $a_{k, s}^{\\dagger}(\\omega)=\\sum_{l=1}^{M} U_{k l} b_{l, s}^{\\dagger}(\\omega)$, where $U_{k l}$ is the unitary matrix describing such an optical network.","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"This means that if Tichy uses U, then Shchesnovich has in place U^†.","category":"page"},{"location":"intro.html#Scattering-matrix","page":"Conventions","title":"Scattering matrix","text":"","category":"section"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"Tichy: ```Using the mode assignment list vecd(vecs)=left(d_1 ldots d_nright) [49], which indicates the mode in which the j th particle resides, the effective scattering matrix becomes","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"$","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"M=U_{\\vec{d}(\\vec{r}), \\vec{d}(\\vec{s})} $ where our convention identifies the j th row (column) with the j th input (output) mode, as illustrated in Fig. 1)(a).```","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"Shchesnovich: identical","category":"page"},{"location":"intro.html#Bunching","page":"Conventions","title":"Bunching","text":"","category":"section"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"The H-matrix follows a convention different from that of Valery Shchesnovich: H_{a,b} = \\sum _{l \\in \\mathcal{K}} U_{l,a} U_{l,b}^{*}, see H_matrix.","category":"page"},{"location":"intro.html#Conventions-regarding-Julia:","page":"Conventions","title":"Conventions regarding Julia:","text":"","category":"section"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"Unlike most languages, the counting goes from 1,2,3... instead of starting at   zero as 0,1,2,...","category":"page"},{"location":"intro.html#Gram-matrices-:","page":"Conventions","title":"Gram matrices :","text":"","category":"section"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"Gram matrices are defined as (phi_iphi_j) ij = 1n. This means that if the label of the photons are swapped, you need to enter another distinguishability matrix with swapped labels accordingly. See GramMatrix.","category":"page"},{"location":"intro.html#Warning-about-precision-:","page":"Conventions","title":"Warning about precision :","text":"","category":"section"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"in EventProbability :","category":"page"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"precision is set to machine precision eps() when doing non-randomised methods   although it is of course larger and this should be implemented   with permanent approximations, see for instance   https://arxiv.org/abs/1904.06229","category":"page"},{"location":"intro.html#Distances-:","page":"Conventions","title":"Distances :","text":"","category":"section"},{"location":"intro.html","page":"Conventions","title":"Conventions","text":"Beware of the different TVD conventions (1/2 in front or not). See tvd for instance.","category":"page"},{"location":"about.html#BosonSampling","page":"About","title":"BosonSampling","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"(Image: ) (Image: )","category":"page"},{"location":"about.html","page":"About","title":"About","text":"This project implements standard and scattershot BosonSampling in Julia, including boson samplers and certification and optimization tools.","category":"page"},{"location":"about.html#Functionalities","page":"About","title":"Functionalities","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"A wide variety of tools are available:","category":"page"},{"location":"about.html","page":"About","title":"About","text":"Boson-samplers, including partial distinguishability and loss\nBunching tools and functions\nVarious tools to validate experimental boson-samplers\nUser-defined optical circuits built from optical elements\nOptimization functions over unitary matrices\nPhoton counting tools for subsets and partitions of the output modes\nTools to study permanent and generalized matrix function conjectures and counter-examples","category":"page"},{"location":"about.html#Installation","page":"About","title":"Installation","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"To install the package, launch a Julia REPL session and type","category":"page"},{"location":"about.html","page":"About","title":"About","text":"julia> using Pkg; Pkg.add(\"BosonSampling\")","category":"page"},{"location":"about.html","page":"About","title":"About","text":"Alternatively type on the ] key. Then enter","category":"page"},{"location":"about.html","page":"About","title":"About","text":"add BosonSampling","category":"page"},{"location":"about.html","page":"About","title":"About","text":"To use the package, write","category":"page"},{"location":"about.html","page":"About","title":"About","text":"using BosonSampling","category":"page"},{"location":"about.html","page":"About","title":"About","text":"in your file.","category":"page"},{"location":"about.html#Related-package","page":"About","title":"Related package","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"The present package takes advantage of efficient computation of matrix permanent from Permanents.jl.  ","category":"page"},{"location":"about.html#Authors-and-License","page":"About","title":"Authors & License","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"Benoît Seron\nAntoine Restivo","category":"page"},{"location":"about.html","page":"About","title":"About","text":"Contact can be made by clicking on our names.","category":"page"},{"location":"about.html","page":"About","title":"About","text":"The original research presented in the package is done in collaboration with Dr. Leonardo Novo, Prof. Nicolas Cerf.","category":"page"},{"location":"about.html","page":"About","title":"About","text":"BosonSampling.jl is licensied under the MIT license.","category":"page"},{"location":"functions/samplers.html","page":"Samplers","title":"Samplers","text":"Modules = [BosonSampling]\nPages = [\"_sampler.jl\"]\nPrivate = false","category":"page"},{"location":"functions/samplers.html#BosonSampling.classical_sampler-Tuple{Any, Any, Any}","page":"Samplers","title":"BosonSampling.classical_sampler","text":"classical_sampler(U, n, m)\nclassical_sampler(;input::Input, interf::Interferometer)\n\nSample photons according to the Distinguishable case.\n\n\n\n\n\n","category":"method"},{"location":"functions/samplers.html#BosonSampling.cliffords_sampler-Tuple{}","page":"Samplers","title":"BosonSampling.cliffords_sampler","text":"cliffords_sampler(;input::Input, interf::Interferometer)\n\nSample photons according to the Bosonic case following Clifford & Clifford algorithm performed (at most) in O(n2^m + Poly(nm)) time and O(m) space.\n\n\n\n\n\n","category":"method"},{"location":"functions/samplers.html#BosonSampling.metropolis_sampler-Tuple{}","page":"Samplers","title":"BosonSampling.metropolis_sampler","text":"metropolis_sampler(;target_pdf, known_pdf, known_sampler, starting_state, n_iter, n_burn = 100, n_thinning = 100)\n\nImplement a metropolis independent sampler for standard boson sampling following. The burn in period n_burnand the thinning interval n_thinning both have default value of 100.\n\nnote: Reference\nhttps://arxiv.org/abs/1705.00686: As the paper is limited to collinionless events, we keep track of this thanks to iterate_until_collisionless.\n\nwarning: Warning\nBurn in perdiod and thinning interval must have the same value.\n\n\n\n\n\n","category":"method"},{"location":"functions/samplers.html#BosonSampling.noisy_sampler-Tuple{}","page":"Samplers","title":"BosonSampling.noisy_sampler","text":"noisy_sampler(;input::Input, reflectivity::Real, interf::Interferometer)\n\nSample partially-distinguishable photons through a lossy interferometer, which runs (at most) in O(n2^m + Poly(nm)) time.\n\nnote: Reference\nhttps://arxiv.org/pdf/1907.00022.pdf\n\n\n\n\n\n","category":"method"},{"location":"tutorial/compute_distr.html#Computing-the-photon-counting-statistics","page":"Counting statistics","title":"Computing the photon counting statistics","text":"","category":"section"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"Given n photons among m modes, one can build several configurations. All of those possible arrangements can be retrieved by using output_mode_occupation","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"julia> n = 2;\n\njulia> m = 2;\n\njulia> output_mode_occupation(n,m)\n4-element Vector{Any}:\n[1, 1]\n[1, 2]\n[2, 1]\n[2, 2]","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"giving a vector of the possible mode assignement lists. We propose here some functions that generate all the associated probabilities to end up in one of such configuration from an Input and an Interferometer. In the following, each generating probability distribution is indexed as output_mode_occupation, that is, p[i] gives the probability to obtain the outcome output_mode_occupation[i].","category":"page"},{"location":"tutorial/compute_distr.html#Theoretical-distribution","page":"Counting statistics","title":"Theoretical distribution","text":"","category":"section"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"We propose here to see the effect of partial distinguishability when two photons interfere through a 1:1 BeamSplitter","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"julia> n = 2; # photon number\n\njulia> m = 2; # mode number\n\njulia> B = BeamSplitter(1/sqrt(2));\n\njulia> proba_bunching = Vector{Float64}(undef, 0);\n\njulia> for distinguishability_param in 0.0:0.01:1.0\n       input = Input{OneParameterInterpolation}(first_modes(n,m), distinguishability_param)\n       p_theo = theoretical_distribution(input=input, interf=B)\n       push!(proba_bunching, p_theo[2])\n       end","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"where we have stored in proba_bunching the probabilities to get one photon in each output port of the beam splitter (see above).","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"(Image: distr)","category":"page"},{"location":"tutorial/compute_distr.html#Noisy-distribution","page":"Counting statistics","title":"Noisy distribution","text":"","category":"section"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"As for noisy_sampler, we sometimes want to take into account imperfections in the experimental realisation of a circuit. One can use noisy_distribution to compute the probabilities to end up in each configuration given by output_mode_occupation from a defined input when using a lossy interferometer","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"julia> n = 3;\n\njulia> m = 5;\n\njulia> distinguishability_param = 0.7;\n\njulia> my_reflectivity = 0.7;\n\njulia> my_input = Input{OneParameterInterpolation}(first_modes(n,m), distinguishability_param);\n\njulia> my_interf = RandHaar(m);\n\njulia> res = noisy_distribution(input=my_input, interf=my_interf, reflectivity=my_reflectivity)\n 3-element Vector{Any}:\n [0.030092342701336063, 0.009174672025065295, 0.012301444632816206, 0.008261320762511275, 0.00825343245181492, 0.009174672025065295, 0.0015318257468957183, 0.007037230327501444, 0.0034542128581951815, 0.0032779849423985887  …  0.01245307508063033, 0.00543392525722553, 0.010053183825728736, 0.013575124678493963, 0.011494371794022762, 0.009403036769288563, 0.009156238120536536, 0.015161445820062795, 0.011494371794022764, 0.04819898039534371]\n [0.023551358197813715, 0.008260895456533175, 0.012221654757509451, 0.012336452058889868, 0.011712852102797554, 0.008260895456533173, 0.0013590732227078874, 0.007212741596498194, 0.0036595492225577186, 0.003983666401759253  …  0.00382520988349487, 0.004571718465896123, 0.009290013877211057, 0.018492288077608613, 0.016830450331890665, 0.01355520468409837, 0.009082179316484165, 0.016223969372706714, 0.016830450331890665, 0.03772226919407445]\n [0.05140000000000507, 0.013849999999999604, 0.016499999999999498, 0.0007700000000000014, 0.0024400000000000055, 0.014479999999999578, 0.0023500000000000053, 0.008769999999999811, 0.0016500000000000037, 0.0005500000000000008  …  0.018739999999999406, 0.005969999999999925, 0.006519999999999903, 0.0058099999999999315, 0.0018300000000000041, 0.002200000000000005, 0.012819999999999646, 0.016089999999999514, 0.0017100000000000038, 0.08629999999999924]","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"Notice that res is a three-component vector containing three probability distributions. In fact, noisy_distribution takes three additional arguments: exact, approx and samp. By default, those optional parameters are set to true meaning that we actually compute three distributions:","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"julia> p_exact = res[1];\n\njulia> p_approx = res[2];\n\njulia> p_samp = res[3];","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"The first one is the noisy version of theoretical_distribution, the second distribution is computed such that the probabilities are truncated by neglecting the highest interference terms. The last distribution is computed thanks to a Metropolis sampler that samples from the exact distribution.","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"(Image: distr)","category":"page"},{"location":"tutorial/compute_distr.html","page":"Counting statistics","title":"Counting statistics","text":"One can allow the computation of the sampled distribution only, by setting exact=false, approx=false when calling noisy_distribution.    ","category":"page"},{"location":"functions/scattering.html","page":"Scattering","title":"Scattering","text":"Modules = [BosonSampling]\nPages = [\"scattering.jl\"]\nPrivate = false","category":"page"},{"location":"functions/scattering.html#BosonSampling.at_most_one_photon_per_bin-Tuple{Vector{Int64}}","page":"Scattering","title":"BosonSampling.at_most_one_photon_per_bin","text":"at_most_one_photon_per_bin(occupancy_vector::Vector{Int})\ncheck_at_most_one_particle_per_mode(occ)\n\nCheck wether occupancy_vector contains more than one photon per site.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.bosonic_amplitude","page":"Scattering","title":"BosonSampling.bosonic_amplitude","text":"bosonic_amplitude(U, input_state, output_state, permanent=ryser)\nprocess_amplitude(U, input_state, output_state, permanent=ryser)\n\nCompute the probability amplitude to go from input_state to output_state through the interferomter U in the Bosonic case.\n\n\n\n\n\n","category":"function"},{"location":"functions/scattering.html#BosonSampling.bosonic_probability-Tuple{Any, Any, Any}","page":"Scattering","title":"BosonSampling.bosonic_probability","text":"bosonic_probability(U, input_state, output_state)\nprocess_probability(U, input_state, output_state)\n\nCompute the probability to go from input_state to output_state through the interferometer U in the Bosonic case.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.check_suppression_law-Tuple{Any}","page":"Scattering","title":"BosonSampling.check_suppression_law","text":"check_suppression_law(event)\n\nCheck if the event is suppressed according to the rule.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.compute_probability!-Union{Tuple{Event{TIn, TOut}}, Tuple{TOut}, Tuple{TIn}} where {TIn<:InputType, TOut<:FockDetection}","page":"Scattering","title":"BosonSampling.compute_probability!","text":"compute_probability(ev::Event{TIn, TOut}) where {TIn<:InputType, TOut<:FockDetection}\n\nGiven an Event, gives the probability to get the outcome TOut when TIn passes though the interferometer ev.interferometer. \t\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.distinguishable_probability","page":"Scattering","title":"BosonSampling.distinguishable_probability","text":"distinguishable_probability(U, input_state, output_state, permanent=ryser)\nprocess_probability_distinguishable(U, input_state, output_state, permanent=ryser)\n\nCompute the probability to go from input_state to output_state through the interferomter U in the Distinguishable case.\n\n\n\n\n\n","category":"function"},{"location":"functions/scattering.html#BosonSampling.fill_arrangement-Tuple{Any}","page":"Scattering","title":"BosonSampling.fill_arrangement","text":"fill_arrangement(occupation_vector)\nfill_arrangement(r::ModeOccupation)\nfill_arrangement(input::Input)\n\nConvert a mode occupation list to a mode assignement.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.iterate_until_collisionless-Tuple{Any}","page":"Scattering","title":"BosonSampling.iterate_until_collisionless","text":"iterate_until_collisionless(f)\n\nSample f until the result is collisionless.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.occupancy_vector_to_mode_occupancy-Tuple{Any}","page":"Scattering","title":"BosonSampling.occupancy_vector_to_mode_occupancy","text":"occupancy_vector_to_mode_occupancy(occupancy_vector)\n\nReturn a partition of occupied modes from an occupancy_vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.occupancy_vector_to_partition-Tuple{Any}","page":"Scattering","title":"BosonSampling.occupancy_vector_to_partition","text":"occupancy_vector_to_partition(occupancy_vector)\noccupancy_vector_to_mode_occupancy(occupancy_vector)\n\nReturn a partition of occupied modes from an occupancy_vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.output_mode_occupation-Tuple{Any, Any}","page":"Scattering","title":"BosonSampling.output_mode_occupation","text":"output_mode_occupation(n::Int, m::Int)\n\nReturn all possible configurations of n photons among m modes.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.process_probability_partial-NTuple{4, Any}","page":"Scattering","title":"BosonSampling.process_probability_partial","text":"process_probability_partial(U, S, input_state, output_state)\nprocess_probability_partial(interf::Interferometer, input_state::Input{TIn} where {TIn<:PartDist},output_state::FockDetection)\n\nCompute the probability to go from input_state to output_state through the interferometer U in the PartDist case where partial distinguishable is described by the GramMatrix S.\n\nnote: Reference\nhttps://arxiv.org/abs/1410.7687\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.random_mode_occupation-Tuple{Int64, Int64}","page":"Scattering","title":"BosonSampling.random_mode_occupation","text":"random_mode_occupation(n::Int, m::Int)\n\nCreate a ModeOccupation from a mode occupation list of n ramdomly placed ones among m sites.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.random_mode_occupation_collisionless-Tuple{Int64, Int64}","page":"Scattering","title":"BosonSampling.random_mode_occupation_collisionless","text":"random_mode_occupation_collisionless(n::Int, m::Int)\n\nCreate a ModeOccupation from a random mode occupation that is likely collisionless.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.random_occupancy-Tuple{Int64, Int64}","page":"Scattering","title":"BosonSampling.random_occupancy","text":"random_occupancy(n::Int, m::Int)\n\nReturn a vector of size m\twith n randomly placed ones.\n\n\n\n\n\n","category":"method"},{"location":"functions/scattering.html#BosonSampling.scattering_matrix-Tuple{Matrix, Vector{Int64}, Vector{Int64}}","page":"Scattering","title":"BosonSampling.scattering_matrix","text":"scattering_matrix(U::Matrix, input_state::Vector{Int}, output_state::Vector{Int})\nscattering_matrix(U::Interferometer, r::ModeOccupation, s::ModeOccupation)\nscattering_matrix(U::Interferometer, i::Input, o::FockDetection)\n\nReturn the submatrix of U whose rows and columns are respectively defined by input_state and output_state.\n\nnote: Reference\nhttp://arxiv.org/abs/quant-ph/0406127v1\n\n\n\n\n\n","category":"method"},{"location":"tutorial/circuits.html#Circuit","page":"Circuits","title":"Circuit","text":"","category":"section"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"BosonSampling.jl allows you to build circuits made of the available Interferometers and UserDefinedInterferometers.","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"The first step is to define an empty circuit that will acts on m=6 modes","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"julia> my_circuit = Circuit(6);\nInterferometer :\n\nType : Circuit\nm : 6","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"Next, we add one by one the components of the circuit, precising on which modes the newly added component acts, by using add_element!","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"julia> add_element!(circuit=my_circuit, interf=Fourier(4), target_modes=[1,2,3,4])\n6×6 Matrix{ComplexF64}:\n0.5+0.0im           0.5+0.0im           0.5+0.0im                   0.5+0.0im          0.0+0.0im  0.0+0.0im\n0.5+0.0im   3.06162e-17+0.5im          -0.5+6.12323e-17im  -9.18485e-17-0.5im          0.0+0.0im  0.0+0.0im\n0.5+0.0im          -0.5+6.12323e-17im   0.5-1.22465e-16im          -0.5+1.83697e-16im  0.0+0.0im  0.0+0.0im\n0.5+0.0im  -9.18485e-17-0.5im          -0.5+1.83697e-16im   2.75546e-16+0.5im          0.0+0.0im  0.0+0.0im\n0.0+0.0im           0.0+0.0im           0.0+0.0im                   0.0+0.0im          1.0+0.0im  0.0+0.0im\n0.0+0.0im           0.0+0.0im           0.0+0.0im                   0.0+0.0im          0.0+0.0im  1.0+0.0im","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"Here, we just have added a Fourier interferometer to our circuit that takes the modes [1,2,3,4] at the input. The output matrix is the unitary representing our circuit and will be updated at each call of add_element!.","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"Let's add some more elements to our circuit:","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"julia> add_element!(circuit=my_circuit, interf=BeamSplitter(1/sqrt(2)), target_modes=[5,6]);\n\njulia> add_element!(circuit=my_circuit, interf=RandHaar(6), target_modes=[1,2,3,4,5,6]);","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"The unitary representing our circuit can be accessed via the field .U, as for any Interferometer","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"julia> my_circuit.U\n6×6 Matrix{ComplexF64}:\n-0.483121-0.246661im    -0.232022-0.397813im   -0.027111-0.1335im     0.296595-0.471387im     -0.25528-0.282524im   0.0866359-0.111526im\n-0.372488+0.0893226im   -0.184263+0.0697938im    0.51829+0.200831im   0.315289+0.238577im   -0.0988814+0.298748im   0.0206645+0.499711im\n-0.504719-0.322371im   -0.0289979+0.458437im   -0.312735-0.156324im  -0.147983+0.354067im    0.0997703-0.0821812im   0.378552-0.0285867im\n-0.26704-0.191813im     0.174817-0.217575im     0.28131+0.345502im  -0.337596-0.230349im     0.505173+0.318283im     0.13136-0.273313im\n-0.227676-0.170793im     0.538223+0.116277im    0.180029-0.501201im  -0.116825-0.0909765im   -0.214777+0.228563im   -0.460068+0.0147747im\n0.0875484-0.0598966im   -0.258087-0.300614im   0.0235678-0.259943im   0.131754+0.42417im     -0.191588+0.497691im   0.0959991-0.522251im","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"Finally, the components of the circuit can also be retrieved via the field .circuit_elements","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"julia> my_circuit.circuit_elements\n3-element Vector{Interferometer}:\nInterferometer :\n\nType : Fourier\nm : 4\nInterferometer :\n\nType : BeamSplitter\nm : 2\nInterferometer :\n\nType : RandHaar\nm : 6","category":"page"},{"location":"tutorial/circuits.html","page":"Circuits","title":"Circuits","text":"that are stored in a Vector{Interferometer}.     ","category":"page"},{"location":"tutorial/permanent_conjectures.html#Permanent-conjectures","page":"Permanent conjectures","title":"Permanent conjectures","text":"","category":"section"},{"location":"tutorial/permanent_conjectures.html","page":"Permanent conjectures","title":"Permanent conjectures","text":"Permanent and generalized matrix functions conjectures are linked to interesting and practical properties of boson samplers, as emphasized for instance by V. S. Shchesnovich in Universality of Generalized Bunching and Efficient Assessment of Boson Sampling as well as in the author's work Boson bunching is not maximized by indistinguishable particles.","category":"page"},{"location":"tutorial/permanent_conjectures.html","page":"Permanent conjectures","title":"Permanent conjectures","text":"To search for new counter examples of a conjecture, one can implement a user-defined search_function(). For instance, random_search_counter_example_bapat_sunder searches for counter examples of the Bapat-Sunder conjecture (see also violates_bapat_sunder) in a brute-force manner, trying a different random set of matrices at each call. One can then use","category":"page"},{"location":"tutorial/permanent_conjectures.html","page":"Permanent conjectures","title":"Permanent conjectures","text":"search_until_user_stop(search_function)","category":"page"},{"location":"tutorial/permanent_conjectures.html","page":"Permanent conjectures","title":"Permanent conjectures","text":"which will iterate the function until you press Ctrl+C to interrupt the computation.","category":"page"},{"location":"tutorial/permanent_conjectures.html","page":"Permanent conjectures","title":"Permanent conjectures","text":"Another important conjecture is the permaent-on-top conjecture, disproved by V. S. Shchesnovich in The permanent-on-top conjecture is false. Special matrices related to this conjecture are given in this package such as the schur_matrix(H), the general partial distinguishability function J(σ) implemented as J_array. From a matrix J, one can recover the density matrix of the internal states with density_matrix_from_J.","category":"page"},{"location":"tutorial/boson_samplers.html#Samplers","page":"Samplers","title":"Samplers","text":"","category":"section"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"This tutorial gives some examples of the usage for the samplers, a classical simulation/approximation of genuine boson samplers. That is, from an Input configuration and an Interferometer we provide tools to sample for the classically hard to simulate boson sampling distribution.","category":"page"},{"location":"tutorial/boson_samplers.html#Bosonic-sampler","page":"Samplers","title":"Bosonic sampler","text":"","category":"section"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"This model is an exact sampler based on the famous algorithm of Clifford-Clifford. (Note that we did not yet implement the faster version for non vanishing boson density.)","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"We present here the general syntax through an example. We simulate n=4 indistinguishable photons among m=16 modes. To do so, we first need to define our Bosonic input with randomly placed photons","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"julia> n = 4;\n\njulia> m = n^2;\n\njulia> my_input = Input{Bosonic}(ModeOccupation(random_occupancy(n,m)))\n Type:Input{Bosonic}\n r:state = [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1]\n n:4\n m:16\n G:GramMatrix{Bosonic}(4, ComplexF64[1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im], nothing, nothing, OrthonormalBasis(nothing))\n distinguishability_param:nothing","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"and we use a random interferometer","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"julia> my_interf = RandHaar(m)\nInterferometer :\n\n Type : RandHaar\n m : 16","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"and then call cliffords_sampler to run the simulation","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"julia> res = cliffords_sampler(input=my_input, interf=my_interf)\n4-element Vector{Int64}:\n 2\n 8\n 15\n 16","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"The output vector of length n tells us which of the output modes contain a photon. One can have a schematic look at the input/output configurations:","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"julia> visualize_sampling(my_input, res)","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"(Image: samp)    ","category":"page"},{"location":"tutorial/boson_samplers.html#Noisy-sampler","page":"Samplers","title":"Noisy sampler","text":"","category":"section"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"We present here the current best known approximate sampler, based on truncating probabilities in k perfectly interfering bosons and n-k perfectly distinguishable ones, an algorithm from https://arxiv.org/pdf/1907.00022.pdf. This decomposition is successful when some partial distinguishability is present. By simplicity, we restrict to the colloquial model of a one parameter x describing the overlap between two different photons (assumed to be equal for all pairs), which is implemented with OneParameterInterpolation. Similary, loss is also accounted for.","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"Let us now explain the usage of this algorithm. As before, one creates an input of particles that are not completely indistinguishable from OneParameterInterpolation","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"julia> my_distinguishability_param = 0.7;\n\njulia> my_mode_occupation = ModeOccupation(random_occupancy(n,m));\n\njulia> my_input = Input{OneParameterInterpolation}(my_mode_occupation, my_distinguishability_param);","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"and still using my_interf with some loss η=0.7, one simulates our noisy boson sampling experiment  with","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"julia> res = noisy_sampler(input=my_input, reflectivity=η, interf=my_interf)\n3-element Vector{Int64}:\n 5\n 7\n 11","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"where we have lost one particle as length(res)=3, meaning that only three output modes are populated by one photon.","category":"page"},{"location":"tutorial/boson_samplers.html#Classical-sampler","page":"Samplers","title":"Classical sampler","text":"","category":"section"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"Finally, we repeat the steps to simulate fully distinguishable particles by using classical_sampler","category":"page"},{"location":"tutorial/boson_samplers.html","page":"Samplers","title":"Samplers","text":"julia> my_mode_occupation = ModeOccupation(random_occupancy(n,m));\n\njulia> my_input = Input{Distinguishable}(my_mode_occupation);\n\njulia> my_interf = RandHaar(m);\n\njulia> res = classical_sampler(input=my_input, interf=my_interf)\n 16-element Vector{Int64}:\n 0\n 0\n 0\n 1\n ⋮\n 0\n 1\n 0","category":"page"},{"location":"functions/bunching.html","page":"Bunching","title":"Bunching","text":"Modules = [BosonSampling]\nPages = [\"bunching.jl\"]\nPrivate = false","category":"page"},{"location":"functions/bunching.html#BosonSampling.H_matrix-Tuple{Any, Vector, Vector}","page":"Bunching","title":"BosonSampling.H_matrix","text":"H_matrix(U, input_state, partition_occupancy_vector)\nH_matrix(interf::Interferometer, i::Input, o::FockDetection)\nH_matrix(interf::Interferometer, i::Input, subset_modes::ModeOccupation)\n\nH matrix for a partition defined by partition_occupancy_vector, see definition in the article below.\n\nnote: Note\nConventions follow the author's Boson bunching is not maximized by indistinguishable particles which are the ones compatible with Tichy's conventions (Shshnovitch has a different one for the evolution of the creation operators).\n\n\n\n\n\n","category":"method"},{"location":"functions/bunching.html#BosonSampling.bunching_probability_brute_force_bosonic-Tuple{Any, Any, Any}","page":"Bunching","title":"BosonSampling.bunching_probability_brute_force_bosonic","text":"bunching_probability_brute_force_bosonic(U, input_state, output_state; print_output = false)\nbunching_probability_brute_force_bosonic(interf::Interferometer, i::Input, subset_modes::ModeOccupation)\n\nBosonic bunching probability by direct summation of all possible cases\n\nbunching_event_proba gives the probability to get the event of 1^n 0^(m-n).\n\n\n\n\n\n","category":"method"},{"location":"functions/bunching.html#BosonSampling.full_bunching_probability-Tuple{Interferometer, Input, Subset}","page":"Bunching","title":"BosonSampling.full_bunching_probability","text":"full_bunching_probability(interf::Interferometer, i::Input, subset_modes::Subset)\nfull_bunching_probability(interf::Interferometer, i::Input, mo::ModeOccupation)\n\nComputes the probability that all n photons end up in the subset of chosen output modes following.\n\nnote: Reference\nUniversality of Generalized Bunching and Efficient Assessment of Boson Sampling\n\n\n\n\n\n","category":"method"},{"location":"benchmarks/bench.html#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/bench.html#Why-Julia?","page":"Benchmarks","title":"Why Julia?","text":"","category":"section"},{"location":"benchmarks/bench.html","page":"Benchmarks","title":"Benchmarks","text":"When simulating a boson sampling experiment, via for instance cliffords_sampler or noisy_sampler, the most time consuming part is the computation of the probabilities. Indeed, the probability to detect the state l_1l_m at the output of an interferometer hatU from an input state ψ_in = k_1k_m is related to the permanent of U through","category":"page"},{"location":"benchmarks/bench.html","page":"Benchmarks","title":"Benchmarks","text":"n_1n_mhatUψ_in^2 = fracPerm(U)^2k_1 k_m l_1  l_m","category":"page"},{"location":"benchmarks/bench.html","page":"Benchmarks","title":"Benchmarks","text":"Having an intensive usage of the Ryser's algorithm to compute such probabilities, we compare here the running time of the latter algorithm from different implementations to compute the permanent of Haar distributed random matrices of dimension n: ","category":"page"},{"location":"benchmarks/bench.html","page":"Benchmarks","title":"Benchmarks","text":"(Image: perm)","category":"page"},{"location":"functions/partitions.html","page":"Partitions","title":"Partitions","text":"Modules = [BosonSampling]\nPages = [\"legacy.jl\", \"partition_expectation_values.jl\", \"partitions/partitions.jl\"]\nPrivate = false","category":"page"},{"location":"functions/partitions.html#BosonSampling.matrix_phi-NTuple{4, Any}","page":"Partitions","title":"BosonSampling.matrix_phi","text":"matrix_phi(k, U, occupancy_vector, n)\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.partition_probability_distribution_distinguishable_rand_walk-Tuple{Any, Any}","page":"Partitions","title":"BosonSampling.partition_probability_distribution_distinguishable_rand_walk","text":"partition_probability_distribution_distinguishable_rand_walk(part, U)\n\nGenerate a vector giving the probability to have k photons in the partition part at the output of the interferomter U.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.proba_partition_bosonic-Tuple{}","page":"Partitions","title":"BosonSampling.proba_partition_bosonic","text":"proba_partition_bosonic(;U, occupancy_vector, input_state=ones(Int, size(U,1)), checks=true)\n\nIndistinguishable version of proba_partition_partial.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.proba_partition_partial-Tuple{}","page":"Partitions","title":"BosonSampling.proba_partition_partial","text":"proba_partition_partial(;U, S, occupancy_vector, input_state, checks=true)\n\nReturn a n+1 sized array giving the probability to find [0,1,...], photons inside the bins given by occupancy_vector at the output of U.\n\nnote: Note\nWe take U of dimension m while M is the scattering matrix, as in Tichy, M_ij = U_d_i _d_j.\nGiven n photons, generally in the first modes, the distinguishability matrix is defined as in Tichy, S_ij = phi_d_iphi_d_j. This is not a problem as it does not depend on the output partition but be aware of it.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.best_partition_size-Tuple{}","page":"Partitions","title":"BosonSampling.best_partition_size","text":"best_partition_size(;m, n, n_subsets, distance=tvd)\n\nReturn the ideal partition_size_vector for a given number of subsets n_subsets and the Haar averaged TVD in second parameter.\n\nnote: Note\nFor a single subset, n_subsets=2 as we need a complete partition, occupying all modes.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.choose_best_average_subset-Tuple{}","page":"Partitions","title":"BosonSampling.choose_best_average_subset","text":"choose_best_average_subset(;m, n, distance=tvd)\n\nReturn the ideal subset size on average and its total variance distance.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.partition_expectation_values-Tuple{Any, Any}","page":"Partitions","title":"BosonSampling.partition_expectation_values","text":"partition_expectation_values(partition_size_vector, partition_counts)\npartition_expectation_values(part_occ::PartitionOccupancy)\n\nReturn the Haar averaged probability of photon number count in binned outputs for Distinguishable and Bosonic particles.\n\nnote: Reference\nhttps://www.nature.com/articles/s41598-017-00044-8.pdf\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.subset_expectation_value-NTuple{4, Any}","page":"Partitions","title":"BosonSampling.subset_expectation_value","text":"subset_expectation_value(subset_size, k, n, m)\n\nReturn the Haar averaged probability to find k from n photons inside a subset of binned output modes of length size_subset among m modes for Distinguishable and Bosonic cases.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.subset_relative_distance_of_averages-Tuple{Any, Any, Any}","page":"Partitions","title":"BosonSampling.subset_relative_distance_of_averages","text":"subset_relative_distance_of_averages(subset_size, n, m)\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.all_mode_configurations-Tuple{Any, Any}","page":"Partitions","title":"BosonSampling.all_mode_configurations","text":"all_mode_configurations(n, n_subset; only_photon_number_conserving=false)\nall_mode_configurations(input_state::Input, part::Partition; only_photon_number_conserving=false)\nall_mode_configurations(input_state::Input, sub::Subset; only_photon_number_conserving=false)\n\nGenerate all possible photon counts of n photons in a partition/subset of n_subset subsets.\n\nnote: Note\nDoes not take into account photon number conservation by default\nThis is the photon counting in partitions and not events outputs but it can be used likewise\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.check_photon_conservation-Tuple{Any, Any, Any}","page":"Partitions","title":"BosonSampling.check_photon_conservation","text":"check_photon_conservation(physical_indexes,  pdf, n; atol=ATOL, partition_spans_all_modes=false)\n\nCheck if probabilities corresponding to non photon number conserving events are zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.compute_probabilities_partition-Tuple{Interferometer, Partition, Input}","page":"Partitions","title":"BosonSampling.compute_probabilities_partition","text":"compute_probabilities_partition(physical_interferometer::Interferometer, part::Partition, input_state::Input)\n\nCompute the probability to find a certain photon counts in a partition part of the output modes for the given interferometer.\n\nReturn `(counts = physical_indexes, probabilities = pdf) corresponding to the occupation numbers in the partition and the associated probability.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.compute_probability!-Union{Tuple{Event{TIn, TOut}}, Tuple{TOut}, Tuple{TIn}} where {TIn<:InputType, TOut<:PartitionCount}","page":"Partitions","title":"BosonSampling.compute_probability!","text":"compute_probability!(ev::Event{TIn,TOut}) where {TIn<:InputType, TOut<:PartitionCount}\ncompute_probability!(ev::Event{TIn,TOut}) where {TIn<:InputType, TOut<:PartitionCountsAll}\n\nGiven a defined Event, computes/updates its probability or set of probabilities (for instance if looking at partition outputs, with MultipleCounts begin filled).\n\nThis function is defined separately as it is most often the most time consuming step of calculations and one may which to separate the evaluation of probabilities from preliminary definitions.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.compute_probability_partition_occupancy-Tuple{Interferometer, PartitionOccupancy, Input}","page":"Partitions","title":"BosonSampling.compute_probability_partition_occupancy","text":"compute_probability_partition_occupancy(physical_interferometer::Interferometer, part_occupancy::PartitionOccupancy, input_state::Input)\n\nCompute the probability to find a partition occupancy.\n\nnote: Note\nInefficient to use multiple times for the same physical setting, rather use computeprobabilitiespartition.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.photon_number_conserving_events-Tuple{Any, Any}","page":"Partitions","title":"BosonSampling.photon_number_conserving_events","text":"photon_number_conserving_events(physical_indexes, n; partition_spans_all_modes=false)\n\nReturn only the events conserving photon number n.\n\nnote: Note\nIf partition_spans_all_modes=false, gives all events with less than n or n photons\nIf partition_spans_all_modes = true only exact photon number conserving physical_indexes\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.photon_number_non_conserving_events-Tuple{Any, Any}","page":"Partitions","title":"BosonSampling.photon_number_non_conserving_events","text":"photon_number_non_conserving_events(physical_indexes, n; partition_spans_all_modes=false)\n\nReturn the elements not conserving the number of photons.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.ranked_partition_list-Tuple{Any}","page":"Partitions","title":"BosonSampling.ranked_partition_list","text":"ranked_partition_list(part_list)\n\nRemove partitions such as [1,2] when [2,1] is already counted as only the size of the partition counts; only keeps vectors of decreasing count.\n\n\n\n\n\n","category":"method"},{"location":"functions/partitions.html#BosonSampling.remove_trivial_partitions!-Tuple{Any}","page":"Partitions","title":"BosonSampling.remove_trivial_partitions!","text":"remove_trivial_partitions!(part_list)\n\nIn a list of partitions sizes, ex. [[2,0],[1,1],[0,2]], keeps only the elements with non trivial subset size, in this ex. only [1,1].\n\n\n\n\n\n","category":"method"},{"location":"tutorial/installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"tutorial/installation.html","page":"Installation","title":"Installation","text":"To install the package, launch a Julia REPL session and type","category":"page"},{"location":"tutorial/installation.html","page":"Installation","title":"Installation","text":"julia> using Pkg; Pkg.add(\"BosonSampling\")","category":"page"},{"location":"tutorial/installation.html","page":"Installation","title":"Installation","text":"Alternatively type on the ] key. Then enter","category":"page"},{"location":"tutorial/installation.html","page":"Installation","title":"Installation","text":"add BosonSampling","category":"page"},{"location":"tutorial/installation.html","page":"Installation","title":"Installation","text":"To use the package, write","category":"page"},{"location":"tutorial/installation.html","page":"Installation","title":"Installation","text":"using BosonSampling","category":"page"},{"location":"tutorial/installation.html","page":"Installation","title":"Installation","text":"in your file.","category":"page"},{"location":"types/events.html","page":"Events","title":"Events","text":"Modules = [BosonSampling]\nPages = [\"events.jl\"]\nPrivate = false","category":"page"},{"location":"types/events.html#BosonSampling.Event","page":"Events","title":"BosonSampling.Event","text":"Event{TIn<:InputType, TOut<:OutputMeasurementType}\n\nEvent linking an input to an output.\n\nFields:\n\t- input_state::Input{TIn}\n\t- output_measurement::TOut\n\t- proba_params::EventProbability\n\t- interferometer::Interferometer\n\n\n\n\n\n","category":"type"},{"location":"types/events.html#BosonSampling.EventProbability","page":"Events","title":"BosonSampling.EventProbability","text":"EventProbability(probability::Union{Nothing, Number})\nEventProbability(mc::MultipleCounts)\n\nHolds the probability or probabilities of an Event.\n\nFields:\n\t- probability::Union{Number,Nothing, MultipleCounts}\n\t- precision::Union{Number,Nothing}\n\t- failure_probability::Union{Number,Nothing}\n\n\n\n\n\n","category":"type"},{"location":"types/events.html#BosonSampling.MultipleCounts","page":"Events","title":"BosonSampling.MultipleCounts","text":"MultipleCounts()\nMultipleCounts(counts, proba)\n\nHolds something like the photon counting probabilities with their respective probability (in order to use them as a single observation). Can be declared empty as a placeholder.\n\nFields:\n\t- counts::Union{Nothing, Vector{ModeOccupation}, Vector{PartitionOccupancy}},\n\t- proba::Union{Nothing,Vector{Real}}\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html","page":"Interferometers","title":"Interferometers","text":"Modules = [BosonSampling]\nPages = [\"interferometers.jl\"]\nPrivate = false","category":"page"},{"location":"types/interferometers.html#BosonSampling.BeamSplitter","page":"Interferometers","title":"BosonSampling.BeamSplitter","text":"BeamSplitter(transmission_amplitude::Float64)\n\nCreates a beam-splitter with tunable transmissivity.\n\nFields:\n    - transmission_amplitude::Float64\n    - U::Matrix{ComplexF64}\n    - m::Int\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Circuit","page":"Interferometers","title":"BosonSampling.Circuit","text":"Circuit(m::Int)\n\nCreates an empty circuit with m input modes. The unitary representing the circuit is accessed via the field .U.\n\nFields:\n    - m::Int\n    - circuit_elements::Vector{Interferometer}\n    - U::Union{Matrix{ComplexF64}, Nothing}\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Fourier","page":"Interferometers","title":"BosonSampling.Fourier","text":"Fourier(m::Int)\n\nCreates a Fourier Interferometer of dimension m.\n\nFields:\n    - m::Int\n    - U::Matrix\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Hadamard","page":"Interferometers","title":"BosonSampling.Hadamard","text":"Hadamard(m::Int)\n\nCreates a Hadamard Interferometer of dimension m.\n\nFields:\n    - m::Int\n    - U::Matrix\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Interferometer","page":"Interferometers","title":"BosonSampling.Interferometer","text":"Supertype to any concrete interferomter type such as UserDefinedInterferometer, RandHaar, Fourier,...\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.PhaseShift","page":"Interferometers","title":"BosonSampling.PhaseShift","text":"PhaseShift(phase::Float64)\n\nCreates a phase-shifter with parameter phase.\n\nFields:\n    - phase::Float64\n    - m::Int\n    - U::Matrix{ComplexF64}\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.RandHaar","page":"Interferometers","title":"BosonSampling.RandHaar","text":"RandHaar(m::Int)\n\nCreates an instance of Interferometer from a Haar distributed unitary matrix of dimension m.\n\nFields:\n    - m::Int\n    - U::Matrix\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.Rotation","page":"Interferometers","title":"BosonSampling.Rotation","text":"Rotation(angle::Float64)\n\nCreates a Rotation matrix with tunable angle.\n\nFields:\n    - angle::Float64\n    - U::Matrix{ComplexF64}\n    - m::Int\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.UserDefinedInterferometer","page":"Interferometers","title":"BosonSampling.UserDefinedInterferometer","text":"UserDefinedInterferometer(U::Matrix)\n\nCreates an instance of Interferometer from a given unitary matrix U.\n\nFields:\n    - m::Int\n    - U::Matrix\n\n\n\n\n\n","category":"type"},{"location":"types/interferometers.html#BosonSampling.add_element!-Tuple{}","page":"Interferometers","title":"BosonSampling.add_element!","text":"add_element!(circuit::Circuit, interf::Interferometer, target_modes::Vector{Int})\n\nAdds the circuit element interf that will be applied on target_modes to the circuit. Will automatically update the unitary representing the circuit.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/bunching.html#Bunching","page":"Bunching","title":"Bunching","text":"","category":"section"},{"location":"tutorial/bunching.html","page":"Bunching","title":"Bunching","text":"Boson bunching is at the heart of many quantum phenomena, and this package has multiple functions related to it in the context of linear optics.","category":"page"},{"location":"tutorial/bunching.html","page":"Bunching","title":"Bunching","text":"Given an interferometer interf, the probability to find all photons of a given input i (with a general state of distinguishability) in a subset subset of the output modes is given by","category":"page"},{"location":"tutorial/bunching.html","page":"Bunching","title":"Bunching","text":"full_bunching_probability(interf::Interferometer, i::Input, subset_modes::Subset)","category":"page"},{"location":"tutorial/bunching.html","page":"Bunching","title":"Bunching","text":"At the heart of this forumla lies the H_matrix(interf::Interferometer, i::Input, subset_modes::ModeOccupation), describing the bunching properties of an interferometer and subset (see Boson bunching is not maximized by indistinguishable particles).","category":"page"},{"location":"tutorial/bunching.html","page":"Bunching","title":"Bunching","text":"Although inefficient, we also provide a check function to evaluate by direct summation the bunching probabilities for Bosonic inputs","category":"page"},{"location":"tutorial/bunching.html","page":"Bunching","title":"Bunching","text":"bunching_probability_brute_force_bosonic(interf::Interferometer, i::Input, subset_modes::ModeOccupation)","category":"page"},{"location":"tutorial/bunching.html","page":"Bunching","title":"Bunching","text":"in order to check the implementation of the above functions.","category":"page"},{"location":"tutorial/partitions.html#Partitions-of-the-output-modes","page":"Partitions","title":"Partitions of the output modes","text":"","category":"section"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"One of the novel tools presented in this package relates the to calculation of photon counts in partition of the output modes, made by grouping output modes into bins.","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"The simplest example would be a subset K, as represented below. More intricate partitions can be considered, with bins K_1,K_2....","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"(Image: interf)","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"The subset K can gather from 0 to n photons. The authors developed new theoretical tools allowing for the efficient computation of this probability distribution, and more refined ones.","category":"page"},{"location":"tutorial/partitions.html#Subsets","page":"Partitions","title":"Subsets","text":"","category":"section"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"Let us now guide you through how to use this package to compute these quantities.","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"Subsets are defined as follow","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"s1 = Subset([1,1,0,0,0])","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"By construction, we do not allow for Susbets to overlap (although there is no theoretical limitation, it is inefficient and messy in practice if considering photon conservation). This can be checked as follow","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"s1 = Subset([1,1,0,0,0])\ns2 = Subset([0,0,1,1,0])\ns3 = Subset([1,0,1,0,0])\n\njulia> check_subset_overlap([s1,s2,s3]) # will fail\nERROR: ArgumentError: subsets overlap","category":"page"},{"location":"tutorial/partitions.html#Partitions","page":"Partitions","title":"Partitions","text":"","category":"section"},{"location":"tutorial/partitions.html#Basic-definitions","page":"Partitions","title":"Basic definitions","text":"","category":"section"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"Consider now the case of partition of the output modes. A partition is composed of multiple subsets. Consider for instance the Hong-Ou-Mandel effect, where we will take the first mode as the first subset, and likewise for the second. (Note that in general subsets will span more than one mode.)","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"n = 2\nm = 2\n\ninput_state = Input{Bosonic}(first_modes(n,m))\n\nset1 = [1,0]\nset2 = [0,1]\nphysical_interferometer = Fourier(m)\npart = Partition([Subset(set1), Subset(set2)])","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"A partition can either span all modes or not (such as the above subset). This can be checked with","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"julia> occupies_all_modes(part)\ntrue","category":"page"},{"location":"tutorial/partitions.html#Direct-output","page":"Partitions","title":"Direct output","text":"","category":"section"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"One can directly compute the various probabilities of photon counts through","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"julia> (physical_indexes, pdf) = compute_probabilities_partition(physical_interferometer, part, input_state)\n┌ Warning: inefficient if no loss: partition occupies all modes thus extra calculations made that are unnecessary\n└ @ BosonSampling ~/.julia/dev/BosonSampling/src/partitions/partitions.jl:162\n(Any[[0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1], [0, 2], [1, 2], [2, 2]], Real[3.083952846180989e-16, 9.63457668695859e-17, 0.49999999999999956, 1.2211830234207134e-16, 4.492871097348413e-17, 8.895480094414932e-17, 0.49999999999999956, 5.516742562771715e-17, 1.6000931161624119e-16])\n\njulia> print_pdfs(physical_indexes, pdf,n; partition_spans_all_modes = true, physical_events_only = true)\n---------------\nPartition results :\nindex = [2, 0], p = 0.49999999999999956\nindex = [1, 1], p = 4.492871097348413e-17\nindex = [0, 2], p = 0.49999999999999956\n---------------","category":"page"},{"location":"tutorial/partitions.html#Single-partition-output-with-Event","page":"Partitions","title":"Single partition output with Event","text":"","category":"section"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"And alternative, cleaner way is to use the formalism of an Event. For this we present an example with another setup, where subsets span multiple modes and the partition is incomplete","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"  n = 2\n  m = 5\n\n  s1 = Subset([1,1,0,0,0])\n  s2 = Subset([0,0,1,1,0])\n\n  part = Partition([s1,s2])","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"We can choose to observe the probability of a single, specific output pattern. In this case, let's choose the case where we find two photons in the first bin, and no photons in the second. We define a PartitionOccupancy to represent this data","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"part_occ = PartitionOccupancy(ModeOccupation([2,0]),n,part)","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"And now let's compute this probability","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"i = Input{Bosonic}(first_modes(n,m))\no = PartitionCount(part_occ)\ninterf = RandHaar(m)\nev = Event(i,o,interf)\n\njulia> compute_probability!(ev)\n\n0.07101423327641303","category":"page"},{"location":"tutorial/partitions.html#All-possible-partition-patterns","page":"Partitions","title":"All possible partition patterns","text":"","category":"section"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"More generally, one will be interested in the probabilities of all possible outputs. This is done as follows","category":"page"},{"location":"tutorial/partitions.html","page":"Partitions","title":"Partitions","text":"o = PartitionCountsAll(part)\nev = Event(i,o,interf)\n\njulia> compute_probability!(ev)\n\nMultipleCounts(PartitionOccupancy[0 in subset = [1, 2]\n0 in subset = [3, 4]\n, 1 in subset = [1, 2]\n0 in subset = [3, 4]\n, 2 in subset = [1, 2]\n0 in subset = [3, 4]\n, 0 in subset = [1, 2]\n1 in subset = [3, 4]\n, 1 in subset = [1, 2]\n1 in subset = [3, 4]\n, 0 in subset = [1, 2]\n2 in subset = [3, 4]\n], Real[0.0181983769680322, 0.027504255046333935, 0.07101423327641304, 0.3447008741997155, 0.23953787529662038, 0.29904438521288507])","category":"page"},{"location":"functions/special_matrices.html","page":"Special_matrices","title":"Special_matrices","text":"Modules = [BosonSampling]\nPages = [\"special_matrices.jl\"]\nPrivate = false","category":"page"},{"location":"functions/special_matrices.html#BosonSampling.fourier_matrix-Tuple{Int64}","page":"Special_matrices","title":"BosonSampling.fourier_matrix","text":"fourier_matrix(n::Int; normalized=true)\n\nReturns a n-by-n Fourier matrix with optional normalization (true by default).\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.gram_matrix_one_param-Tuple{Int64, Real}","page":"Special_matrices","title":"BosonSampling.gram_matrix_one_param","text":"gram_matrix_one_param(n::Int, x::Real)\n\nReturns a n-by-n Gram matrix parametrized by the real 0  x  1.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.hadamard_matrix","page":"Special_matrices","title":"BosonSampling.hadamard_matrix","text":"hadamard_matrix(n::Int; normalized=true)\n\nReturns a n-by-n Hadamard matrix with optional normalization (true by default).\n\n\n\n\n\n","category":"function"},{"location":"functions/special_matrices.html#BosonSampling.perturbed_gram_matrix-Tuple{Any, Any}","page":"Special_matrices","title":"BosonSampling.perturbed_gram_matrix","text":"perturbed_gram_matrix(M, epsilon)\n\nReturns a Gram matrix generated by the columns of M which are perturbed by a Gaussian quantity of variance epsilon once normalized.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.perturbed_unitary-Tuple{Any, Any}","page":"Special_matrices","title":"BosonSampling.perturbed_unitary","text":"perturbed_unitary(U, epsilon)\n\nReturns a unitary matrix whose columns are generating vector perturbed by a random Gaussian quantity with variance epsilon once normalized.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix-Tuple{Int64}","page":"Special_matrices","title":"BosonSampling.rand_gram_matrix","text":"rand_gram_matrix(n::Int)\n\nReturns a full rank n-by-n random Gram matrix.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix_from_orthonormal_basis-Tuple{Any, Any}","page":"Special_matrices","title":"BosonSampling.rand_gram_matrix_from_orthonormal_basis","text":"rand_gram_matrix_from_orthonormal_basis(n::Int, r::Int)\n\nReturns a n-by-n random Gram matrix that generates orthonormal basis of r vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix_positive-Tuple{Int64}","page":"Special_matrices","title":"BosonSampling.rand_gram_matrix_positive","text":"rand_gram_matrix_positive(n::Int)\n\nReturns a positive elements n-by-n random Gram matrix of full rank.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix_rank-Tuple{Any, Any}","page":"Special_matrices","title":"BosonSampling.rand_gram_matrix_rank","text":"rand_gram_matrix_rank(n::Int, r::Int)\n\nReturns a n-by-n random Gram matrix of maximum rank and great likelihood r.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_gram_matrix_real-Tuple{Any}","page":"Special_matrices","title":"BosonSampling.rand_gram_matrix_real","text":"rand_gram_matrix_real(n::Int)\n\nReturns a real n-by-n random Gram matrix of full rank.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.rand_haar-Tuple{Int64}","page":"Special_matrices","title":"BosonSampling.rand_haar","text":"rand_haar(n::Int)\n\nReturns a n-by-n Haar distributed unitary matrix following https://case.edu/artsci/math/esmeckes/MeckesSAMSILecture2.pdf.\n\n\n\n\n\n","category":"method"},{"location":"functions/special_matrices.html#BosonSampling.sylvester_matrix-Tuple{Any}","page":"Special_matrices","title":"BosonSampling.sylvester_matrix","text":"sylvester_matrix(p::Int; normalized=true)\n\nReturns a 2^p-by-2^p Sylvester matrix with optional normalization (true by default) following https://arxiv.org/abs/1502.06372.\n\n\n\n\n\n","category":"method"},{"location":"functions/visualize.html","page":"Visualization","title":"Visualization","text":"Modules = [BosonSampling]\nPages = [\"visual.jl\"]\nPrivate = false","category":"page"},{"location":"functions/visualize.html#BosonSampling.visualize_proba-Tuple{Input, Any, Any}","page":"Visualization","title":"BosonSampling.visualize_proba","text":"visualize_proba(input::Input, output, data)\n\nDraw a schematic representation associated to the event with probability data.    \n\n\n\n\n\n","category":"method"},{"location":"functions/visualize.html#BosonSampling.visualize_sampling-Tuple{Input, Any}","page":"Visualization","title":"BosonSampling.visualize_sampling","text":"visualize_sampling(input::Input, output)\n\nDraw a schematic representation of the setup.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/basic_usage.html#Basic-usage","page":"Basic usage","title":"Basic usage","text":"","category":"section"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"This tutorial will introduce you to the definition of the building blocks for your boson sampling experiment. The general workflow for a simple simulation is to define an Input that enters into a Interferometer and ask what is the probability to get a defined OutputMeasurement.","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"They are linked together through an Event type, which holds the respective probabilities. As the computation of probabilities is often the most time consuming step, you need to explicitly ask for it through compute_probability! which updates the EventProbability data.","category":"page"},{"location":"tutorial/basic_usage.html#Input","page":"Basic usage","title":"Input","text":"","category":"section"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"BosonSampling.jl provides three distinct types of input depending on the distinguishability of the particles we want to make interfere: Bosonic, PartDist and Distinguishable. The type PartDist is a container for different models of partial distinguishability. Currently available models are:","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"OneParameterInterpolation\nRandomGramMatrix\nUserDefinedGramMatrix\nUndef","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"In order to define the input, we first need to provide a ModeOccupation that describes the repartition of the particles among the modes.","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> n = 3; # photon number\n\njulia> m = 6; # mode number\n\njulia> my_mode_occupation = ModeOccupation(random_occupancy(n,m))\n state = [1, 0, 0, 1, 1, 0]","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"In the example above, my_mode_occupation has been created thanks to random_occupancy that randomly places n particles among m modes. Here we have one particle in the first, fourth and fifth modes. Let's build an input made off indistinguishable photons by using the type Bosonic","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_input = Input{Bosonic}(my_mode_occupation)\n Type:Input{Bosonic}\n r:state = [1, 1, 0, 0, 1, 0]\n n:3\n m:6\n G:GramMatrix{Bosonic}(3, ComplexF64[1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im], nothing, nothing, OrthonormalBasis(nothing))\n distinguishability_param:nothing","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"where my_input holds the information defined above and an additional field, the GramMatrix:","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"help?> GramMatrix\n\n Fields:\n  - n::Int: photons number\n  - S::Matrix: Gram matrix\n  - rank::Union{Int, Nothing}\n  - distinguishability_param::Union{Real, Nothing}\n  - generating_vectors::OrthonormalBasis","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"which contains everything about the distinguishability of the particles within my_input. The matrix itself can be accessed via the field S:","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_input.G.S\n 3×3 Matrix{ComplexF64}:\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n 1.0+0.0im  1.0+0.0im  1.0+0.0im\n 1.0+0.0im  1.0+0.0im  1.0+0.0im","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"One can do the same for Distinguishable particles placed in the first_modes","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_mode_occupation = first_modes(n,m);\n\njulia> my_input = Input{Distinguishable}(my_mode_occupation);\n\njulia> my_input.G.S\n 3×3 Matrix{ComplexF64}:\n 1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.0+0.0im","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"We can move now to the PartDist case with a model of partially distinguishable particles defined by a RandomGramMatrix","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_input = Input{RandomGramMatrix}(first_modes(n,m));","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"where my_input.G.S is a randomly generated Gram matrix.","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Finally, one can resort to a OneParameterInterpolation model taking a linear distinguishability parameter as an additional argument in the definition of my_input:","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_mode_occupation = ModeOccupation(random_occupancy(n,m));\n\njulia> my_distinguishability_param = 0.7;\n\njulia> my_input = Input{OneParameterInterpolation}(my_mode_occupation, my_distinguishability_param)\n Type:Input{OneParameterInterpolation}\n r:state = [1, 1, 1, 0, 0, 0]\n n:3\n m:6\n G:GramMatrix{OneParameterInterpolation}(3, [1.0 0.7 0.7; 0.7 1.0 0.7; 0.7 0.7 1.0], nothing, 0.7, OrthonormalBasis(nothing))\n distinguishability_param:0.7","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Notice that the Bosonic Gram matrix is recovered for my_distinguishability_param = 1 while we find the Distinguishable case for my_distinguishability_param = 0.  ","category":"page"},{"location":"tutorial/basic_usage.html#Interferometer","page":"Basic usage","title":"Interferometer","text":"","category":"section"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"The second building block of our boson sampler is the interferometer we want to apply on my_input. A common practice to study boson sampling is to pick up at random a Haar distributed unitary matrix that will represent the interferometer. This can be done as follow:","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_random_interf = RandHaar(m);\n\njulia> my_random_interf.U\n 6×6 Matrix{ComplexF64}:\n -0.398793-0.162392im     0.500654+0.239935im   -0.0822224-0.189055im     0.361289+0.048139im   -0.0639807+0.521608im   -0.0608676-0.226158im\n 0.331232+0.312918im    -0.362433-0.0585051im    0.172619+0.157846im       0.6224-0.0656408im   -0.186285+0.215539im    -0.233294-0.274952im\n -0.085377+0.00861048im  -0.427763+0.1271im      -0.140581-0.541889im   -0.0407117+0.219472im     0.499523-0.0486383im  -0.0711764-0.416309im\n -0.180636+0.294002im    -0.376353+0.0943096im   -0.489498-0.206616im   0.00169099-0.221399im    -0.260862+0.305118im     0.313454+0.373737im\n 0.619915-0.0776736im     0.29879-0.323099im    -0.398401-0.371214im    -0.132369+0.0411683im   -0.242868+0.0913286im  -0.0282651-0.179273im\n 0.179322+0.240927im    0.0369079+0.110875im     0.100647-0.0206654im   -0.153966+0.577663im     0.154379+0.372127im    -0.366647+0.481086im","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"where we have accessed to the matrix thanks to the field .U. We may also need to use a specific interferometer such as a Discrete Fourier Transform or the Hadamard transform:","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_fourier_interf = Fourier(m);\n\njulia> is_unitary(my_fourier_interf.U)\n true\n\njulia> my_hadamard_tf = Hadamard(2^m);\n\njulia> is_unitary(my_hadamard_tf.U)\n true","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"where we have checked the unitarity thanks to is_unitary.","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"The implemented interferometers are listed in Interferometer but it is still possible to define our own unitary by resorting to the type UserDefinedInterferometer:","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> sigma_y = [0 -1im; 1im 0];\n\njulia> my_interf = UserDefinedInterferometer(sigma_y)\n Type : UserDefinedInterferometer\n m : 2\n Unitary :\n ┌────────┬────────┐\n │ Col. 1 │ Col. 2 │\n ├────────┼────────┤\n │  0+0im │  0-1im │\n │  0+1im │  0+0im │\n └────────┴────────┘","category":"page"},{"location":"tutorial/basic_usage.html#OutputMeasurement","page":"Basic usage","title":"OutputMeasurement","text":"","category":"section"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Now consider what you want to observe, in this numerical experiment. If looking at the case of a single output, we would use an OutputMeasurement type called FockDetection. Other types are currently defined such as PartitionCount, which would evaluate the probability of finding a photon count in a partition of the output modes.","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Similary to the definition of the Input, it is also possible to define an output configuration from a ModeOccupation","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> n = 3;\n\njulia> m=n^2;\n\njulia> my_mode_occupation = first_modes(n,m);\n\njulia> my_input = Input{Bosonic}(my_mode_occupation)\n Type:Input{Bosonic}\n r:state = [1, 1, 1, 0, 0, 0, 0, 0, 0]\n n:3\n m:9\n G:GramMatrix{Bosonic}(3, ComplexF64[1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im], nothing, nothing, OrthonormalBasis(nothing))\n distinguishability_param:nothing\n\njulia> out = FockDetection(my_mode_occupation)\n FockDetection(state = [1, 1, 1, 0, 0, 0, 0, 0, 0])","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"using FockDetection. Additionally, we can define an Event that stores our input-interferometer-output content","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_interf = Fourier(my_input.m)\n Type : Fourier\n m : 9\n\njulia> ev = Event(my_input, out, my_interf)\n Event{Bosonic, FockDetection}(Input:\n\n Type:Input{Bosonic}\n r:state = [1, 1, 1, 0, 0, 0, 0, 0, 0]\n n:3\n m:9\n G:GramMatrix{Bosonic}(3, ComplexF64[1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im; 1.0 + 0.0im 1.0 + 0.0im 1.0 + 0.0im], nothing, nothing, OrthonormalBasis(nothing))\n distinguishability_param:nothing, FockDetection(state = [1, 1, 1, 0, 0, 0, 0, 0, 0]), EventProbability(nothing, nothing, nothing), Interferometer :\n\n Type : Fourier\n m : 9)","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"and then one can compute the probability that this event occurs","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> compute_probability!(ev)\n 0.015964548319225575","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"Those steps can be repeated for different types of input. Let's say we want to compute the probability that partially distinguishable photons populating the n=3 first modes of m=9 modes end up in the n last output modes when interfering through a random interferometer:","category":"page"},{"location":"tutorial/basic_usage.html","page":"Basic usage","title":"Basic usage","text":"julia> my_input = Input{RandomGramMatrix}(first_modes(n,m)); # input from a randomly generated Gram matrix\n\njulia> out = FockDetection(ModeOccupation([0,0,0,0,0,0,1,1,1]));\n\njulia> my_interf = RandHaar(m);\n\njulia> ev = Event(my_input, out, my_interf);\n\njulia> compute_probability!(ev)\n 0.014458823860031098","category":"page"},{"location":"functions/distributions.html","page":"Distributions","title":"Distributions","text":"Modules = [BosonSampling]\nPages = [\"distribution.jl\"]\nPrivate = false","category":"page"},{"location":"functions/distributions.html#BosonSampling.noisy_distribution-Tuple{}","page":"Distributions","title":"BosonSampling.noisy_distribution","text":"noisy_distribution(;input::Input, reflectivity::Real, interf::Interferometer, exact=true, approx=true, samp=true)\n\nCompute the exact and/or approximated and/or sampled probability distribution of all possible output configurations of partially-distinguishable photons through a lossy interferometer. By default, exact, approx and samp are set to true meaning that noisy_distribution returns an array containing the three distributions.\n\nnote: Note\nThe probabilities within a distribution are indexed following the same order as output_mode_occupation(n,m)\nThe approximated distribution has error and failure probability of 1e^-4.\n\nnote: Reference\nhttps://arxiv.org/pdf/1809.01953.pdf\n\n\n\n\n\n","category":"method"},{"location":"functions/distributions.html#BosonSampling.theoretical_distribution-Tuple{}","page":"Distributions","title":"BosonSampling.theoretical_distribution","text":"theoretical_distribution(;input::Input, interf::Interferometer, i=nothing)\n\nCompute the probability distribution of all possible output configurations of fully/partially-indistinguishable photons through a lossless interferometer.\n\nnote: Note\nThe probabilities within the distribution are indexed following the same order as output_mode_occupation(n,m)\nIf i (with default value nothing) is set to an integer theoretical_distribution returns the probability to find the photons in the i'th configuration given by output_mode_occupation\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html","page":"Permanent conjectures","title":"Permanent conjectures","text":"Modules = [BosonSampling]\nPages = [\"bapat_sunder.jl\", \"counter_example_functions.jl\", \"counter_example_numerical_search.jl\", \"permanent_on_top.jl\"]\nPrivate = false","category":"page"},{"location":"functions/permanent_conjectures.html#BosonSampling.violates_bapat_sunder","page":"Permanent conjectures","title":"BosonSampling.violates_bapat_sunder","text":"violates_bapat_sunder(A,B, tol = ATOL)\n\nChecks if matrices A and B violate the Bapat-Sunder conjecture, see Boson bunching is not maximized by indistinguishable particles\n\n\n\n\n\n","category":"function"},{"location":"functions/permanent_conjectures.html#BosonSampling.add_columns_to_make_square_unitary-Tuple{Any}","page":"Permanent conjectures","title":"BosonSampling.add_columns_to_make_square_unitary","text":"add_columns_to_make_square_unitary(M_dagger)\n\nMakes a square matrix U of which the first columns are M_dagger, which has to be unitary by itself by a random choice of vectors that are then orthonormalized.\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.cholesky_semi_definite_positive-Tuple{Any}","page":"Permanent conjectures","title":"BosonSampling.cholesky_semi_definite_positive","text":"cholesky_semi_definite_positive(A)\n\ncholesky decomposition (A = R' * R) for a sdp but not strictly positive definite matrix\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.incorporate_in_a_unitary-Tuple{Any}","page":"Permanent conjectures","title":"BosonSampling.incorporate_in_a_unitary","text":"incorporate_in_a_unitary(X)\n\nincorporates the renormalized matrix X in a double sized unitary through the proof of Lemma 29  of Aaronson Arkipov seminal The Computational Complexity of Linear Optics\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.incorporate_in_a_unitary_non_square-Tuple{Any}","page":"Permanent conjectures","title":"BosonSampling.incorporate_in_a_unitary_non_square","text":"incorporate_in_a_unitary_non_square(X)\n\nsame as incorporate_in_a_unitary but for a matrix renormalized X of type (m,n) with m >= n generates a minimally sized unitary (ex 99 interferometer for the 72 M' of the first counter example of drury)\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.random_search_counter_example_bapat_sunder-Tuple{}","page":"Permanent conjectures","title":"BosonSampling.random_search_counter_example_bapat_sunder","text":"random_search_counter_example_bapat_sunder(;m,n,r, physical_H = true)\n\nBrute-force search of counter-examples of rank r.\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.search_until_user_stop-Tuple{Any}","page":"Permanent conjectures","title":"BosonSampling.search_until_user_stop","text":"search_until_user_stop(search_function)\n\nRuns search_function until user-stop (Ctrl+C).\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.J_array-Tuple{Any, Any}","page":"Permanent conjectures","title":"BosonSampling.J_array","text":"J_array(theta, n)\n\nreturns the J as defined in in Eq.10 of Universality of Generalized Bunching and Efficient Assessment of Boson Sampling, with the permutations coming in the order given by permutations(collect(1:n))\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.density_matrix_from_J-Tuple{Any, Any}","page":"Permanent conjectures","title":"BosonSampling.density_matrix_from_J","text":"density_matrix_from_J(J,n)\n\ndensity matrix associated to a J function as defined in Universality of Generalized Bunching and Efficient Assessment of Boson Sampling, computed through Eq. 46.\n\n\n\n\n\n","category":"method"},{"location":"functions/permanent_conjectures.html#BosonSampling.schur_matrix-Tuple{Any}","page":"Permanent conjectures","title":"BosonSampling.schur_matrix","text":"schur_matrix(H)\n\ncomputes the Schur matrix as defined in Eq. 1 of Linear Algebra and its Applications 490 (2016) 196–201\n\n\n\n\n\n","category":"method"},{"location":"types/measurements.html","page":"Measurements","title":"Measurements","text":"Modules = [BosonSampling]\nPages = [\"measurements.jl\"]\nPrivate = false","category":"page"},{"location":"types/measurements.html#BosonSampling.FockDetection","page":"Measurements","title":"BosonSampling.FockDetection","text":"FockDetection(s::ModeOccupation)\n\nMeasuring the probability of getting the ModeOccupation s at the output.\n\nFields:\n    - s::ModeOccupation\n\n\n\n\n\n","category":"type"},{"location":"types/measurements.html#BosonSampling.PartitionCount","page":"Measurements","title":"BosonSampling.PartitionCount","text":"PartitionCount(part_occupancy::PartitionOccupancy)\n\nMeasuring the probability of getting a specific count for a given partition part_occupancy.\n\nFields:\n    - part_occupancy::PartitionOccupancy\n\n\n\n\n\n","category":"type"},{"location":"types/measurements.html#BosonSampling.PartitionCountsAll","page":"Measurements","title":"BosonSampling.PartitionCountsAll","text":"PartitionCountsAll(part::Partition)\n\nMeasuring all possible counts probabilities in the partition part.\n\nFields:\n    - part::Partition\n\n\n\n\n\n","category":"type"},{"location":"index.html#BosonSampling.jl-Documentation","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"","category":"section"},{"location":"index.html#About","page":"BosonSampling.jl Documentation","title":"About","text":"","category":"section"},{"location":"index.html","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"Pages = [\"about.md\"]","category":"page"},{"location":"index.html#Tutorial","page":"BosonSampling.jl Documentation","title":"Tutorial","text":"","category":"section"},{"location":"index.html","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"Pages = [\"tutorial/installation.md\",\n        \"tutorial/basic_usage.md\",\n        \"tutorial/user_defined_models.md\",\n        \"tutorial/boson_samplers.md\",\n        \"tutorial/partitions.md\",\n        \"tutorial/bunching.md\",\n        \"tutorial/certification.md\",\n        \"tutorial/optimization.md\",\n        \"tutorial/compute_distr.md\",\n        \"tutorial/circuits.md\",\n        \"tutorial/permanent_conjectures.md\"]","category":"page"},{"location":"index.html#API","page":"BosonSampling.jl Documentation","title":"API","text":"","category":"section"},{"location":"index.html#Types","page":"BosonSampling.jl Documentation","title":"Types","text":"","category":"section"},{"location":"index.html","page":"BosonSampling.jl Documentation","title":"BosonSampling.jl Documentation","text":"### Functions","category":"page"},{"location":"types/type_functions.html","page":"Type utilities","title":"Type utilities","text":"Modules = [BosonSampling]\nPages = [\"type_functions.jl\"]\nPrivate = false","category":"page"},{"location":"types/type_functions.html#BosonSampling.get_parametric_type-Tuple{Any}","page":"Type utilities","title":"BosonSampling.get_parametric_type","text":"get_parametric_type(i)\n\nReturn the types T1,..,Tn of a parametric type i::T{T1,..,Tn}.\n\nnote: Note\nIf the parametric type has only one parameter, use get_parametric_type(i)[1].\nIf no parametric type, returns an array containing the type itself.\n\n\n\n\n\n","category":"method"}]
}
